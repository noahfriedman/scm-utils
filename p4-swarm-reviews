#!/usr/bin/env perl
# $Id: p4-swarm-reviews,v 1.6 2016/07/01 19:38:54 friedman Exp $

package REST::Generic;

use strict;
use warnings qw(all);

use Carp  qw(verbose croak);
use REST::Client;
use JSON;

sub __DEBUG (&)
{
  return unless $ENV{SWARM_REVIEWS_DEBUG};
  my $fn = shift;
  eval { &$fn };
  print STDERR "\n", $@ if $@;
}

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  my $self = bless {}, $class;

  $self->{json} = JSON->new->pretty->canonical;

  if (@_) # process any remaining args as key/value pairs
    {
      my %defaults = @_;
      while (my ($key, $val) = each %defaults)
        {
          $self->{attr}->{$key} = $val;
        }
    }

  my $host = $self->{attr}->{host};
  $self->{client} = REST::Client->new (host => $host);

  return $self;
}

sub json_encode { my $self = shift; $self->{json}->encode (@_) }
sub json_decode { my $self = shift; $self->{json}->decode (@_) }

# By default we do no auth; return void.
sub http_auth_token { return }

sub _http_send_headers
{
  my $self = shift;

  return  { 'Content-Type'   => 'application/json',
            Accept           => 'application/json',
            $self->http_auth_token,
          };
}

sub GET
{
  my ($self, $path, %args) = @_;

  my $query = $self->urlencode_args (%args);
  $path .= "?$query" if defined $query && $query ne "";

  __DEBUG { my $host = $self->{attr}->{host};
            print(STDERR "#" x 40,
                  " $self\->GET() entry\n\n",
                  "URL: $host$path\n\n")
          };

  my $client  = $self->{client};
  my $headers = $self->_http_send_headers;

  $client->GET ($path, $headers);
  my $code     = $client->responseCode;
  my $type     = $client->responseHeader ('Content-Type');
  my $response = $client->responseContent;

  __DEBUG { print(STDERR "HEADERS: (http result $code)\n",
                  (map { sprintf ("   %s: %s\n", $_,
                                  $client->responseHeader ($_));
                       } $client->responseHeaders), "\n");
          };

  croak $response unless $type =~ m=application/json=i;

  my $json    = $self->{json};
  my $decoded = $json->decode ($response);

  unless ($code == 200)
    {
      if (exists $decoded->{errorMessages}) # jira
        { croak sprintf ("Error: %s\n", join ("\n", @{$decoded->{errorMessages}})) }
      elsif (exists $decoded->{message})     # jira
        { croak sprintf ("Error %s: %s\n", $decoded->{'status-code'}, $decoded->{message}) }
      elsif (exists $decoded->{error})     # swarm
        { croak sprintf ("Error %s: %s\n", $path, $decoded->{error}) }
      else
        { croak sprintf ("Error on query: %s\n", $path) }
    }

  __DEBUG { print(STDERR "RESULT: ",
                  $json->encode ($decoded),
                  "\n", "#" x 40, " $self\->GET() exit\n\n");
          };

  return $decoded;
}

sub urlencode_args
{
  my $self = shift;
  my %args = @_;

  my @kv;
  while (my ($key, $val) = each %args)
    {
      if (ref $val eq 'ARRAY')
        {
          if (exists    $self->{list_array}->{__ALL}
              || exists $self->{list_array}->{$key})
            {
              my $list = join (",", @$val);
              $list =~ s/([^---0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
              push @kv, "$key=$list";
            }
          else
            {
              push @kv, map { s/([^---0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
                              "${key}[]=$_"
                            } @$val;
            }
        }
      else
        {
          $val =~ s/([^0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
          push @kv, "$key=$val";
        }
    }
  join ("&", sort @kv);
}


package REST::Swarm;

use strict;
use warnings qw(all);

use base qw(REST::Generic);

our $api_version = 'v2'; # 'v1.2'

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  my $self = $class->SUPER::new (@_);

  $self->{list_array}->{fields} = 1; # currently true for all swarm rest calls
  return $self;
}

sub search
{
  my ($self, %args) = @_;

  my $result = $self->GET ("/api/$api_version/reviews/", %args);
  return $result->{reviews};
}

sub activity
{
  my ($self, %args) = @_;

  my @all;
  while (1)
    {
      # This query will only return 100 results max at a time.
      my $result = $self->GET ("/api/$api_version/activity/", %args);
      push @all, @{$result->{activity}};

      my $len = scalar @{$result->{activity}};
      last unless $len >= 100;
      $args{after} = $result->{lastSeen};
    }
  return \@all;
}


package REST::Jira;

use strict;
use warnings qw(all);

use MIME::Base64;

use base qw(REST::Generic);

our $api_version = 2;

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  my $self = $class->SUPER::new (@_);

  $self->{list_array}->{__ALL} = 1;
  return $self;
}

sub http_auth_token
{
  my $self = shift;

  my $user  = $self->{attr}->{user} || "anonymous";
  my $pass  = $self->{attr}->{pass} || "";
  my $basic = encode_base64 (sprintf ("%s:%s", $user, $pass));

  return (Authorization => sprintf ("Basic %s", $basic));
}

sub search
{
  my ($self, %args) = @_;

  my $max = $args{maxResults};  # may be undef
  # Raise the default from 50 to 1000 if caller did not specify.
  $args{maxResults} ||= 1000;
  $args{startAt}      =    0;  # always start at 0

  my @issues;
  while (1)
    {
      my $result = $self->POST ("/rest/api/$api_version/search", %args);
      push @issues, @{$result->{issues}};

      $max = $result->{total} unless defined $max;
      last if @issues >= $max;
      $args{startAt} = scalar @issues; # fetch next batch;
    }
  return \@issues;
}

sub issue_remotelinks
{
  my ($self, $issue, %args) = @_;

  my $path = "/rest/api/$api_version/issue/$issue/remotelink";
  my $result = $self->GET ($path, %args);
  return $result;
}


#package P4::Swarm;

#use strict;
#use warnings qw(all);

#use NF::P4cmd;

# Swarm stores data for a review N as a perforce user counter of the
# form 'swarm-review-X' where X is the following transform of N.  This
# value can be retrieved via "p4 counter -u KEY" or "p4 key KEY".
#sub review_counter_name
#{
#  my $change = shift;
#  sprintf ("swarm-review-%08x", 0xffffffff - $change);
#}


package main;

use strict;
use warnings qw(all);

use POSIX qw(strftime);

my $swarm_host = 'http://swarm.perforce.com';
my $jira_host  = 'http://jira.perforce.com:8080';
my $jira_user  = 'build';
my $jira_pass  = 'rein4ce';

my @review_fields   = (qw(id author description
                          changes commits commitStatus
                          created updated
                          state pending));

my @activity_fields = (qw(id action user change streams));

sub timefmt
{
  strftime ("%Y-%m-%d %H:%M:%S %z (%a)", localtime ($_[0]));
}

sub parse_review
{
  my ($found, $list) = @_;

  my %special = map { $_ => undef } (qw(id changes commits description));
  for my $review (@$list)
    {
      my $id = $review->{id};
      next if exists $found->{$id};

      my $f = $found->{$id} = {};
      map { $f->{$_} = $review->{$_}
              unless exists $special{$_};
          } keys %$review;

      my $changes = $review->{changes};
      my $commits = $review->{commits};
      if (defined $commits && @$commits)
        {
          $f->{commits} = $commits;

          # Remove any numbers that appear in in commits from changes
          my %rem = map { $_ => undef } @$changes;
          map { delete $rem{$_} } @$commits;
          $changes = [sort keys %rem];
        }
      $f->{orig}  = shift @$changes if @$changes;
      $f->{changes} = $changes if @$changes;

      if ($f->{commits} && ! $f->{orig})
        {
          # Someone requested a review of a commit already made, not a shelf.
          push @{$f->{commit_by}}, [ $f->{commits}->[0], $f->{author} ];
        }

      $f->{jira} = $1
        if (defined $review->{description}
          && $review->{description} =~ m=(https?://\S*jira\S*/browse/[---a-z0-9]+)=i)
    }
}

sub parse_activity
{
  my ($found, $list) = @_;

  for my $activity (@$list)
    {
      my $review;
      for my $stream (@{$activity->{streams}})
        {
          if ($stream =~ /^review-(\d+)$/)
            {
              $review = $found->{$1};
              last;
            }
        }
      next unless defined $review;

      my $action = $activity->{action};
      my $fn = { committed => sub
                 { push (@{$review->{commit_by}},
                         [ $activity->{change}, $activity->{user} ]);
                 },

                 approved  => sub
                 { push @{$review->{approved_by}}, $activity->{user} },

                 requested => sub
                 { $review->{review_for} = $activity->{user} },

                 "updated files in" => sub
                 { $review->{review_for} = $activity->{user} },
               }->{$action} if defined $action;
      &$fn if defined $fn;
    }
}

sub prune_needed
{
  my ($need, $reviews) = @_;
  map { map { map { delete $need->{$_}
                  } (ref $_ eq 'ARRAY' ? @$_ : $_);
            } values %$_;
      } @$reviews;
}

sub printr
{
  my $label = shift;

  my @a = map { if (ref $_ eq 'ARRAY')
                  {
                    if (ref $_->[0] eq 'ARRAY')
                      { map { sprintf ("%s (%s)", @$_) } @$_ }
                    else
                      { sprintf ("%s (%s)", @$_) }
                  }
                else
                  { $_ }
              } @_;

  my $s = sprintf ("\t%-14s %s\n", $label, join (" ", @a));
  substr ($s, length ($label) + 1, 1) = ":";
  print $s;
}

sub print_review
{
  my ($id, $data) = @_;

  printf "%s/reviews/%s\n", $swarm_host, $id;

  printr ("JIRA", $1) if $data->{jira} && $data->{jira} =~ m=.*/(.*)$=;

  printr ("Requested by", $data->{review_for})
    if $data->{review_for} && $data->{review_for} ne $data->{author};

  if ($data->{approved_by})
    {
      printr ("State", $data->{state},
              sprintf ("(%s)", join (", ", @{$data->{approved_by}})),
              ($data->{pending} ? "*pending*" : ()));
    }
  else
    {
      printr ("State", join (", ", $data->{state},
                             ($data->{pending} ? "pending" : ())));
    }

  printr ("User shelf",    $data->{orig}, "($data->{author})") if $data->{orig};
  if    ($data->{commit_by}) { printr ("Commits", $data->{commit_by}) }
  elsif ($data->{commits})   { printr ("Commits", @{$data->{commits}}) }

  printr ("Commit Error", $data->{commitStatus}->{error})
    if (defined $data->{commitStatus}
        && ref $data->{commitStatus} eq 'HASH'
        && defined $data->{commitStatus}->{error});

  printr ("Swarm intern", @{$data->{changes}}) if $data->{changes};

  printr ("Created", timefmt ($data->{created}));
  printr ("Updated", timefmt ($data->{updated}));

  print "\n";
}

sub search
{
  my ($swarm, $need, $found, $fields) = (shift, shift, shift, shift);
  my $reviews = $swarm->search (fields => $fields, @_);
  if ($reviews && @$reviews)
    {
      prune_needed ($need, $reviews);
      parse_review ($found, $reviews);
    }
}

sub jira_issue_reviews
{
  my $jira = REST::Jira->new (host => $jira_host,
                              user => $jira_user,
                              pass => $jira_pass,
                             );

  my $result = $jira->issue_remotelinks (@_);
  my @review;
  for my $remote (@$result)
    {
      next unless $remote->{object}->{url} =~ m=/reviews/(\d+)=;
      push @review, $1;
    }
  return @review;
}

sub main
{
  # This only matters when output is not to a tty, but it keeps any errors
  # synchronized with regular output.
  STDOUT->autoflush(1);
  STDERR->autoflush(1);

  my @list;
  for my $arg (@_)
    {
      if ($arg =~ /^\d+$/)
        { push @list, $arg }
      else
        {
          my @result = eval { jira_issue_reviews ($arg) };
          if ($@) { print STDERR "$arg: ", $@, "\n" }
          elsif (scalar @result == 0)
            { print STDERR "$arg: no reviews found for this issue.\n" }
          else
            { push @list, @result }
        }
    }

  unless (@list)
    {
      if (@_)
        { print STDERR "No results to display.\n" }
      else
        { print STDERR "You must provide review/shelf numbers or jira tasks!\n" }
      exit 1;
    }

  my $swarm = REST::Swarm->new ( host => $swarm_host );
  my %need = (map { $_ => undef } @list);
  my %found;

  search ($swarm, \%need, \%found, \@review_fields, ids => \@list);
  search ($swarm, \%need, \%found, \@review_fields, change => [keys %need])
    if %need;

  my @stream = map { "review-$_" } sort keys %found;
  if (@stream)
    {
      my $activity = $swarm->activity (fields => \@activity_fields,
                                       stream => \@stream);
      parse_activity (\%found, $activity);
    }

  map { print STDERR "$_: no Swarm reference found.\n" } sort keys %need;
  print STDERR "\n" if %need;

  map { print_review ($_, $found{$_}) } sort keys %found;
}

main (@ARGV);

# eof
