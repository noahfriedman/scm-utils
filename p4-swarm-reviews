#!/usr/bin/env perl
# $Id: p4-swarm-reviews,v 1.3 2016/06/24 00:59:52 friedman Exp $

package REST::Swarm;

use strict;
use warnings qw(all);

use Carp  qw(verbose croak);
use REST::Client;
use JSON;

our $api_version = 'v2'; # 'v1.2'

sub __DEBUG (&)
{
  return unless $ENV{SWARM_REVIEWS_DEBUG};
  my $fn = shift;
  eval { &$fn };
  print STDERR "\n", $@ if $@;
}

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  my $self = bless {}, $class;

  $self->{json} = JSON->new->pretty->canonical;

  if (@_) # process any remaining args as key/value pairs
    {
      my %defaults = @_;
      while (my ($key, $val) = each %defaults)
        {
          $self->{attr}->{$key} = $val;
        }
    }

  my $host = $self->{attr}->{host};
  $self->{client} = REST::Client->new (host => $host);

  $self->{list_array}->{fields} = 1; # currently true for all swarm rest calls

  return $self;
}

sub json_encode { my $self = shift; $self->{json}->encode (@_); }
sub json_decode { my $self = shift; $self->{json}->decode (@_); }

sub urlencode_args
{
  my $self = shift;
  my %args = @_;

  my @kv;
  while (my ($key, $val) = each %args)
    {
      if (ref $val eq 'ARRAY')
        {
          if (exists $self->{list_array}->{$key})
            {
              my $list = join (",", @$val);
              $list =~ s/([^---0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
              push @kv, "$key=$list";
            }
          else
            {
              push @kv, map { s/([^---0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
                              "${key}[]=$_"
                            } @$val;
            }
        }
      else
        {
          $val =~ s/([^0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
          push @kv, "$key=$val";
        }
    }
  join ("&", sort @kv);
}

sub GET
{
  my ($self, $path, %args) = @_;

  my $query = $self->urlencode_args (%args);
  $path .= "?$query" if defined $query && $query ne "";

  __DEBUG { my $host = $self->{attr}->{host};
            print(STDERR "#" x 40,
                  " $self\->GET() entry\n\n",
                  "URL: $host$path\n\n")
          };

  my $client  = $self->{client};
  my $headers = { 'Content-Type'   => 'application/json',
                  Accept           => 'application/json',
                };

  $client->GET ($path, $headers);
  my $code     = $client->responseCode;
  my $type     = $client->responseHeader ('Content-Type');
  my $response = $client->responseContent;

  __DEBUG { print(STDERR "HEADERS: (http result $code)\n",
                  (map { sprintf ("   %s: %s\n", $_,
                                  $client->responseHeader ($_));
                       } $client->responseHeaders), "\n");
          };

  croak $response unless $type =~ m=application/json=i;

  my $json    = $self->{json};
  my $decoded = $json->decode ($response);

  unless ($code == 200)
    {
      croak sprintf ("%d Error %s: %s\n", $code, $path, $decoded->{error})
        if exists $decoded->{error};
      croak sprintf ("%d Error on query: %s\n", $code, $path);
    }

  __DEBUG { print(STDERR "RESULT: ",
                  $json->encode ($decoded),
                  "\n", "#" x 40, " $self\->GET() exit\n\n");
          };

  return $decoded;
}

sub search
{
  my ($self, %args) = @_;

  my $result = $self->GET ("/api/$api_version/reviews/", %args);
  return $result->{reviews};
}

sub activity
{
  my ($self, %args) = @_;

  my @all;
  while (1)
    {
      # This query will only return 100 results max at a time.
      my $result = $self->GET ("/api/$api_version/activity/", %args);
      push @all, @{$result->{activity}};

      my $len = scalar @{$result->{activity}};
      last unless $len >= 100;
      $args{after} = $result->{lastSeen};
    }
  return \@all;
}


#package P4::Swarm;

#use strict;
#use warnings qw(all);

#use NF::P4cmd;

# Swarm stores data for a review N as a perforce user counter of the
# form 'swarm-review-X' where X is the following transform of N.  This
# value can be retrieved via "p4 counter -u KEY" or "p4 key KEY".
#sub review_counter_name
#{
#  my $change = shift;
#  sprintf ("swarm-review-%08x", 0xffffffff - $change);
#}


package main;

use strict;
use warnings qw(all);

use POSIX qw(strftime);

my $swarm_host = 'http://swarm.perforce.com';

my @review_fields   = (qw(id author
                          changes commits commitStatus
                          created updated
                          state pending));

my @activity_fields = (qw(id action user change streams));

sub timefmt
{
  strftime ("%Y-%m-%d %H:%M:%S %z (%a)", localtime ($_[0]));
}

sub parse_review
{
  my ($found, $list) = @_;

  my %special = map { $_ => undef } (qw(id changes commits));
  for my $review (@$list)
    {
      my $id = $review->{id};
      next if exists $found->{$id};

      my $f = $found->{$id} = {};
      map { $f->{$_} = $review->{$_}
              unless exists $special{$_};
          } keys %$review;

      my $changes = $review->{changes};
      my $commits = $review->{commits};
      if (defined $commits && @$commits)
        {
          $f->{commits} = $commits;

          # Remove any numbers that appear in in commits from changes
          my %rem = map { $_ => undef } @$changes;
          map { delete $rem{$_} } @$commits;
          $changes = [sort keys %rem];
        }
      $f->{orig}  = shift @$changes if @$changes;
      $f->{changes} = $changes if @$changes;

      if ($f->{commits} && ! $f->{orig})
        {
          # Someone requested a review of a commit already made, not a shelf.
          push @{$f->{commit_by}}, [ $f->{commits}->[0], $f->{author} ];
        }
    }
}

sub parse_activity
{
  my ($found, $list) = @_;

  for my $activity (@$list)
    {
      my $review;
      for my $stream (@{$activity->{streams}})
        {
          if ($stream =~ /^review-(\d+)$/)
            {
              $review = $found->{$1};
              last;
            }
        }
      next unless defined $review;

      my $action = $activity->{action};
      my $fn = { committed => sub
                 { push (@{$review->{commit_by}},
                         [ $activity->{change}, $activity->{user} ]);
                 },

                 approved  => sub
                 { push @{$review->{approved_by}}, $activity->{user} },

                 requested => sub
                 { $review->{review_for} = $activity->{user} },

                 "updated files in" => sub
                 { $review->{review_for} = $activity->{user} },
               }->{$action} if defined $action;
      &$fn if defined $fn;
    }
}

sub prune_needed
{
  my ($need, $reviews) = @_;
  map { map { map { delete $need->{$_}
                  } (ref $_ eq 'ARRAY' ? @$_ : $_);
            } values %$_;
      } @$reviews;
}

sub printr
{
  my $label = shift;

  my @a = map { if (ref $_ eq 'ARRAY')
                  {
                    if (ref $_->[0] eq 'ARRAY')
                      { map { sprintf ("%s (%s)", @$_) } @$_ }
                    else
                      { sprintf ("%s (%s)", @$_) }
                  }
                else
                  { $_ }
              } @_;

  my $s = sprintf ("\t%-14s %s\n", $label, join (" ", @a));
  substr ($s, length ($label) + 1, 1) = ":";
  print $s;
}

sub print_review
{
  my ($id, $data) = @_;

  printf "%s/reviews/%s\n", $swarm_host, $id;

  printr ("Requested by", $data->{review_for})
    if $data->{review_for} && $data->{review_for} ne $data->{author};

  if ($data->{approved_by})
    {
      printr ("State", $data->{state},
              sprintf ("(%s)", join (", ", @{$data->{approved_by}})),
              ($data->{pending} ? "*pending*" : ()));
    }
  else
    {
      printr ("State", join (", ", $data->{state},
                             ($data->{pending} ? "pending" : ())));
    }

  printr ("User shelf",    $data->{orig}, "($data->{author})") if $data->{orig};
  if    ($data->{commit_by}) { printr ("Commits", $data->{commit_by}) }
  elsif ($data->{commits})   { printr ("Commits", @{$data->{commits}}) }

  printr ("Commit Error", $data->{commitStatus}->{error})
    if (defined $data->{commitStatus}
        && ref $data->{commitStatus} eq 'HASH'
        && defined $data->{commitStatus}->{error});

  printr ("Swarm intern", @{$data->{changes}}) if $data->{changes};

  printr ("Created", timefmt ($data->{created}));
  printr ("Updated", timefmt ($data->{updated}));
  print "\n";
}

sub search
{
  my ($swarm, $need, $found, $fields) = (shift, shift, shift, shift);
  my $reviews = $swarm->search (fields => $fields, @_);
  if ($reviews && @$reviews)
    {
      prune_needed ($need, $reviews);
      parse_review ($found, $reviews);
    }
}

sub main
{
  unless (@_)
    {
      print STDERR "You must provide review or shelf numbers!\n";
      exit 1;
    }

  # This only matters when output is not to a tty, but it keeps any errors
  # synchronized with regular output.
  STDOUT->autoflush(1);
  STDERR->autoflush(1);

  my $swarm = REST::Swarm->new ( host => $swarm_host );
  my %need = (map { $_ => undef } @_);
  my %found;

  search ($swarm, \%need, \%found, \@review_fields, ids => \@_);
  search ($swarm, \%need, \%found, \@review_fields, change => [keys %need])
    if %need;

  my @stream = map { "review-$_" } sort keys %found;
  my $activity = $swarm->activity (fields => \@activity_fields,
                                   stream => \@stream);
  parse_activity (\%found, $activity);

  map { print STDERR "$_: no Swarm reference found.\n" } sort keys %need;
  print STDERR "\n" if %need;

  map { print_review ($_, $found{$_}) } sort keys %found;
}

main (@ARGV);

# eof
