#!/usr/bin/env perl
# $Id: p4-swarm-reviews,v 1.8 2016/09/27 21:45:03 friedman Exp $

use lib "$ENV{HOME}/lib/perl";


package REST::Swarm;

use strict;
use warnings qw(all);

use base qw(NF::REST);

our $api_version = 'v2'; # 'v1.2'

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  $class->SUPER::new (array_as_vector => { __ALL => 1 }, @_);
}

sub search
{
  my ($self, %args) = @_;

  my $result = $self->GET ("/api/$api_version/reviews/", %args);
  return $result->{reviews};
}

sub activity
{
  my ($self, %args) = @_;

  my @all;
  while (1)
    {
      # This query will only return 100 results max at a time.
      my $result = $self->GET ("/api/$api_version/activity/", %args);
      push @all, @{$result->{activity}};

      my $len = scalar @{$result->{activity}};
      last unless $len >= 100;
      $args{after} = $result->{lastSeen};
    }
  return \@all;
}


package REST::Jira;

use strict;
use warnings qw(all);

# The reference implementation does everything we need.
use base qw(NF::REST::Jira);


#package P4::Swarm;

#use strict;
#use warnings qw(all);

#use NF::P4cmd;

# Swarm stores data for a review N as a perforce user counter of the
# form 'swarm-review-X' where X is the following transform of N.  This
# value can be retrieved via "p4 counter -u KEY" or "p4 key KEY".
#sub review_counter_name
#{
#  my $change = shift;
#  sprintf ("swarm-review-%08x", 0xffffffff - $change);
#}


package main;

use strict;
use warnings qw(all);

use POSIX qw(strftime);

my $swarm_host = 'http://swarm.perforce.com';
my $jira_host  = 'http://jira.perforce.com:8080';
my $jira_user  = 'build';
my $jira_pass  = 'rein4ce!';

my @review_fields   = (qw(id author description
                          changes commits commitStatus
                          created updated
                          state pending));

my @activity_fields = (qw(id action user change streams));

sub timefmt
{
  strftime ("%Y-%m-%d %H:%M:%S %z (%a)", localtime ($_[0]));
}

sub parse_review
{
  my ($found, $list) = @_;

  my %special = map { $_ => undef } (qw(id changes commits description));
  for my $review (@$list)
    {
      my $id = $review->{id};
      next if exists $found->{$id};

      my $f = $found->{$id} = {};
      map { $f->{$_} = $review->{$_}
              unless exists $special{$_};
          } keys %$review;

      my $changes = $review->{changes};
      my $commits = $review->{commits};
      if (defined $commits && @$commits)
        {
          $f->{commits} = $commits;

          # Remove any numbers that appear in commits from changes
          my %rem = map { $_ => undef } @$changes;
          map { delete $rem{$_} } @$commits;
          $changes = [sort keys %rem];
        }
      $f->{orig}  = shift @$changes if @$changes;
      $f->{changes} = $changes if @$changes;

      if ($f->{commits} && ! $f->{orig})
        {
          # Someone requested a review of a commit already made, not a shelf.
          push @{$f->{commit_by}}, [ $f->{commits}->[0], $f->{author} ];
        }

      $f->{jira} = $1
        if (defined $review->{description}
          && $review->{description} =~ m=(https?://\S*jira\S*/browse/[---a-z0-9]+)=i)
    }
}

sub parse_activity
{
  my ($found, $list) = @_;

  for my $activity (@$list)
    {
      my $review;
      for my $stream (@{$activity->{streams}})
        {
          if ($stream =~ /^review-(\d+)$/)
            {
              $review = $found->{$1};
              last;
            }
        }
      next unless defined $review;

      my $action = $activity->{action};
      my $fn = { committed => sub
                 { push (@{$review->{commit_by}},
                         [ $activity->{change}, $activity->{user} ]);
                 },

                 approved  => sub
                 { push @{$review->{approved_by}}, $activity->{user} },

                 requested => sub
                 { $review->{review_for} = $activity->{user} },

                 "updated files in" => sub
                 { $review->{review_for} = $activity->{user} },
               }->{$action} if defined $action;
      &$fn if defined $fn;
    }
}

sub prune_needed
{
  my ($need, $reviews) = @_;
  map { map { map { delete $need->{$_}
                  } (ref $_ eq 'ARRAY' ? @$_ : $_);
            } values %$_;
      } @$reviews;
}

sub printr
{
  my $label = shift;

  my @a = map { if (ref $_ eq 'ARRAY')
                  {
                    if (ref $_->[0] eq 'ARRAY')
                      { map { sprintf ("%s (%s)", @$_) } @$_ }
                    else
                      { sprintf ("%s (%s)", @$_) }
                  }
                else
                  { $_ }
              } @_;

  my $s = sprintf ("\t%-14s %s\n", $label, join (" ", @a));
  substr ($s, length ($label) + 1, 1) = ":";
  print $s;
}

sub print_review
{
  my ($id, $data) = @_;

  printf "%s/reviews/%s\n", $swarm_host, $id;

  printr ("JIRA", $1) if $data->{jira} && $data->{jira} =~ m=.*/(.*)$=;

  printr ("Requested by", $data->{review_for})
    if $data->{review_for} && $data->{review_for} ne $data->{author};

  if ($data->{approved_by})
    {
      printr ("State", $data->{state},
              sprintf ("(%s)", join (", ", @{$data->{approved_by}})),
              ($data->{pending} ? "*pending*" : ()));
    }
  else
    {
      printr ("State", join (", ", $data->{state},
                             ($data->{pending} ? "pending" : ())));
    }

  printr ("User shelf",    $data->{orig}, "($data->{author})") if $data->{orig};
  if    ($data->{commit_by}) { printr ("Commits", $data->{commit_by}) }
  elsif ($data->{commits})   { printr ("Commits", @{$data->{commits}}) }

  printr ("Commit Error", $data->{commitStatus}->{error})
    if (defined $data->{commitStatus}
        && ref $data->{commitStatus} eq 'HASH'
        && defined $data->{commitStatus}->{error});

  printr ("Swarm intern", @{$data->{changes}}) if $data->{changes};

  printr ("Created", timefmt ($data->{created}));
  printr ("Updated", timefmt ($data->{updated}));

  print "\n";
}

sub search
{
  my ($swarm, $need, $found, $fields) = (shift, shift, shift, shift);
  my $reviews = $swarm->search (fields => $fields, @_);
  if ($reviews && @$reviews)
    {
      prune_needed ($need, $reviews);
      parse_review ($found, $reviews);
    }
}

sub jira_issue_reviews
{
  my $jira = REST::Jira->new (host => $jira_host,
                              user => $jira_user,
                              pass => $jira_pass,
                             );

  my $result = $jira->issue_remotelinks (@_);
  my @review;
  for my $remote (@$result)
    {
      next unless $remote->{object}->{url} =~ m=/reviews/(\d+)=;
      push @review, $1;
    }
  return @review;
}

sub main
{
  local $ENV{NF_REST_DEBUG} = $ENV{SWARM_REVIEWS_DEBUG};

  # This only matters when output is not to a tty, but it keeps any errors
  # synchronized with regular output.
  STDOUT->autoflush(1);
  STDERR->autoflush(1);

  my @list;
  for my $arg (@_)
    {
      if ($arg =~ /^\d+$/)
        { push @list, $arg }
      else
        {
          my @result = eval { jira_issue_reviews ($arg) };
          if ($@) { print STDERR "$arg: ", $@, "\n" }
          elsif (scalar @result == 0)
            { print STDERR "$arg: no reviews found for this issue.\n" }
          else
            { push @list, @result }
        }
    }

  unless (@list)
    {
      if (@_)
        { print STDERR "No results to display.\n" }
      else
        { print STDERR "You must provide review/shelf numbers or jira tasks!\n" }
      exit 1;
    }

  my $swarm = REST::Swarm->new ( host => $swarm_host );
  my %need = (map { $_ => undef } @list);
  my %found;

  search ($swarm, \%need, \%found, \@review_fields, ids => \@list);
  search ($swarm, \%need, \%found, \@review_fields, change => [keys %need])
    if %need;

  my @stream = map { "review-$_" } sort keys %found;
  if (@stream)
    {
      my $activity = $swarm->activity (fields => \@activity_fields,
                                       stream => \@stream);
      parse_activity (\%found, $activity);
    }

  map { print STDERR "$_: no Swarm reference found.\n" } sort keys %need;
  print STDERR "\n" if %need;

  map { print_review ($_, $found{$_}) } sort keys %found;
}

main (@ARGV);

# eof
