#!/usr/bin/env perl
# $Id: p4-swarm-reviews,v 1.2 2016/06/22 22:07:12 friedman Exp $

package REST::Swarm;

use strict;
use warnings qw(all);

use Carp  qw(verbose croak);
use REST::Client;
use JSON;

sub __DEBUG (&)
{
  return unless $ENV{SWARM_REVIEWS_DEBUG};
  my $fn = shift;
  eval { &$fn };
  print STDERR "\n", $@ if $@;
}

sub new
{
  my $type = shift;
  my $class = ref ($type) || $type;
  my $self = bless {}, $class;

  $self->{json} = JSON->new->pretty->canonical;

  if (@_) # process any remaining args as key/value pairs
    {
      my %defaults = @_;
      while (my ($key, $val) = each %defaults)
        {
          $self->{attr}->{$key} = $val;
        }
    }

  my $host = $self->{attr}->{host};
  $self->{client} = REST::Client->new (host => $host);

  return $self;
}

sub json_encode { my $self = shift; $self->{json}->encode (@_); }
sub json_decode { my $self = shift; $self->{json}->decode (@_); }

sub urlencode_args
{
  my $self = shift;
  my %args = @_;

  my @kv;
  while (my ($key, $val) = each %args)
    {
      if (ref $val eq 'ARRAY')
        {
          push @kv, map { s/([^0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
                          "${key}[]=$_"
                        } @$val;
        }
      else
        {
          $val =~ s/([^0-9a-zA-Z_,.])/sprintf ("%%%02X", ord($1))/eg;
          push @kv, "$key=$val";
        }
    }
  join ("&", sort @kv);
}

sub GET
{
  my ($self, $path, %args) = @_;

  my $query = $self->urlencode_args (%args);
  $path .= "?$query" if defined $query && $query ne "";

  __DEBUG { my $host = $self->{attr}->{host};
            print(STDERR "#" x 40,
                  " $self\->GET() entry\n\n",
                  "URL: $host$path\n\n")
          };

  my $client  = $self->{client};
  my $headers = { 'Content-Type'   => 'application/json',
                  Accept           => 'application/json',
                };

  $client->GET ($path, $headers);
  my $code     = $client->responseCode;
  my $type     = $client->responseHeader ('Content-Type');
  my $response = $client->responseContent;

  __DEBUG { print(STDERR "HEADERS: (http result $code)\n",
                  (map { sprintf ("   %s: %s\n", $_,
                                  $client->responseHeader ($_));
                       } $client->responseHeaders), "\n");
          };

  croak $response unless $type =~ m=application/json=i;

  my $json    = $self->{json};
  my $decoded = $json->decode ($response);

  unless ($code == 200)
    {
      croak sprintf ("%d Error %s: %s\n", $code, $path, $decoded->{error})
        if exists $decoded->{error};
      croak sprintf ("%d Error on query: %s\n", $code, $path);
    }

  __DEBUG { print(STDERR "RESULT: ",
                  $json->encode ($decoded),
                  "\n", "#" x 40, " $self\->GET() exit\n\n");
          };

  return $decoded;
}

sub search
{
  my ($self, %args) = @_;

  my $result = $self->GET ("/api/v1.2/reviews/", %args);
  my @review = @{$result->{reviews}};
  return \@review;
}

sub review
{
  my ($self, $id, %args) = @_;

  my $result = $self->GET ("/api/v1.2/reviews/$id", %args);
  my @review = $result->{review};
  return \@review;
}


package main;

use strict;
use warnings qw(all);

use POSIX qw(strftime);

my $swarm_host = 'http://swarm.perforce.com';

my @swarm_fields = (qw(id
                       changes commits commitStatus
                       created updated
                       state pending));

sub timefmt
{
  strftime ("%Y-%m-%d %H:%M:%S %z", localtime ($_[0]));
}

sub parse_review
{
  my ($found, $list) = @_;

  my %special = map { $_ => undef } (qw(id changes commits));
  for my $review (@$list)
    {
      my $id = $review->{id};
      next if exists $found->{$id};

      my $f = $found->{$id} = {};
      map { $f->{$_} = $review->{$_}
              unless exists $special{$_};
          } keys %$review;

      my $changes = $review->{changes};
      my $commits = $review->{commits};
      $f->{orig}  = shift @$changes;
      if (defined $commits && @$commits)
        {
          $f->{commits} = $commits;

          # Remove any numbers that appear in in commits from changes
          my %rem = map { $_ => undef } @$changes;
          map { delete $rem{$_} } @$commits;
          $changes = [sort keys %rem];
        }
      $f->{changes} = $changes if @$changes;
    }
}

sub prune_needed
{
  my ($need, $reviews) = @_;
  map { map { map { delete $need->{$_}
                  } (ref $_ eq 'ARRAY' ? @$_ : $_);
            } values %$_;
      } @$reviews;
}

sub main
{
  unless (@_)
    {
      print STDERR "You must provide review or shelf numbers!\n";
      exit 1;
    }

  my $swarm = REST::Swarm->new ( host => $swarm_host );

  my %need = (map { $_ => undef } @_);
  my %found;

  my @fields = (fields => \@swarm_fields);
  my $reviews = $swarm->search (@fields, change => \@_);
  if ($reviews && @$reviews)
    {
      prune_needed (\%need, $reviews);
      parse_review (\%found, $reviews);
    }

  for my $id (keys %need)
    {
      # don't croak on errors; usually 404
      my $result = eval { $swarm->review ($id, @fields) };
      print STDERR $@ if $ENV{SWARM_REVIEWS_DEBUG};

      if ($result && @$result)
        {
          prune_needed (\%need,  $result);
          parse_review (\%found, $result);
        }
    }

  map { print STDERR "$_: no Swarm reference found.\n" } sort keys %need;
  print STDERR "\n" if %need;

  map { my $data = $found{$_};
        printf "%s/reviews/%s\n", $swarm_host, $_;
        printf "\tUser shelf:    %s\n", $data->{orig};

        printf "\tSwarm changes: %s\n", join (" ", @{$data->{changes}})
          if $data->{changes};

        printf "\tCommitted:     %s\n", join (" ", @{$data->{commits}})
          if $data->{commits};

        printf "\tCommit Error:  %s\n", $data->{commitStatus}->{error}
          if (defined $data->{commitStatus}
              && ref $data->{commitStatus} eq 'HASH'
              && defined $data->{commitStatus}->{error});

        printf "\tState:         %s%s\n", $data->{state},
          ($data->{pending} ? ", pending" : "");

        printf "\tCreated:       %s\n", timefmt ($data->{created});
        printf "\tUpdate:        %s\n", timefmt ($data->{updated});
        print "\n";
      } sort keys %found;
}

main (@ARGV);

# eof
