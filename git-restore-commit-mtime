#!/usr/bin/env perl
# git-restore-commit-mtime --- sync local files modtime with commit history
# Author: Noah Friedman <friedman@splode.com>
# Created: 2014-11-17
# Public domain

# Commentary:

# Usage: cd to-top-of-repo; git-restore-commit-mtime;
# optional arg: revision range, e.g. "@{yesterday}..@"

# If you regularly pull a snapshot (say, once a day) and want to fix mtimes
# on just files committed since then, you can use a revision range like the
# above example, which will significantly prune the commit list that has
# to be scanned.  This is by far the slowest part of the operation.

# TODO:
#
# * find root of git repo and modify file names to be relative to that, so
#   that you don't have to be at the root of the repo before running command.
# * Verbose options.  Options in general.
# * Documentation.

# Code:

$^W = 1;  # enable warnings

use strict;

# Like `` but avoids shell exec/reparsing.
sub cmd_out
{
  my $fh;
  my $pid = open ($fh, "-|");
  die "fork: $!" unless defined $pid;

  local $/ = wantarray ? $/ : undef;
  return <$fh> if $pid;                # parent

  exec ({ $_[0] } @_) or die "exec: $_[0]: $!";  # child
}

sub git_live_files
{
  map { $_ => undef }
      split (/\0/, cmd_out (qw(git ls-tree -z -r --name-only @)));
}

sub git_log_data
{
  @_ = '@' unless @_;
  splice( @_, 1, 0, '--' ) if ( @_ > 1
                                && $_[0] =~ m=\@|.+?\.\..+=
                                && $_[1] ne '--' );

  # n.b. adding paths to get commits with files slows this down considerably.
  # We skip the file-less commits below anyway.
  my $data = cmd_out (qw(git log -z --format=format:%ct --name-only --relative), @_);
  my %tbl;

  # Generate a map of what files are "live", so that we can ignore file
  # names in the commit logs that are not relevant.
  my %have = git_live_files ();

  # This was found to be the best compromise between speed and memory.
  # Overly complex regex matching is slower because of backtracking, and
  # pre-splitting the data chunk on \0\0 doubles the amount of memory used.
  my ($off, $len) = (0, length $data);
  while ($off < $len)
    {
      my $end = ($data =~ m/\0\0/g) ? pos($data) - 2 : $len;
      my ($mtime, $files)
        = split (/\n/, substr ($data, $off, $end - $off), 2);

      if ($files)
        {
          $mtime =~ s/^.*\0//;  # skip changelists with no files
          map { $tbl{$_} = $mtime
                  unless exists $tbl{$_} || !exists $have{$_};
              } split (/\0/, $files);
        }

      $off = $end;
    }

  return unless %tbl;
  return \%tbl;
}

# After restoring file mtimes, set directory mtimes to the time of the most
# recently edited file in that directory.
# Directories that are empty other than other directories will inherit the
# timestamp of some immediate subdirectory, but which one is not specified.
sub set_mtimes
{
  my $tbl = shift;

  my %dirtbl;
  while (my ($file, $mtime) = each %$tbl)
    {
      (my $dir = $file) =~ s=/[^/]*$==;
      $dir = "." if $dir eq $file;
      $dirtbl{$dir} = $mtime
        unless exists $dirtbl{$dir} && $dirtbl{$dir} > $mtime;

      utime ($mtime, $mtime, $file);
    }

  while (my ($dir, $mtime) = each %dirtbl)
    {
      utime ($mtime, $mtime, $dir);

      while ($dir =~ m=/=)
        {
          $dir =~ s=/[^/]*$==;
          utime ($mtime, $mtime, $dir) unless exists $dirtbl{$dir};
        }
    }
}

sub main
{
  my $tbl = git_log_data (@_);
  set_mtimes ($tbl);
}

main (@ARGV);

# eof
