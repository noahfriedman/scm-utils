#!/usr/bin/env perl
# p4-not-added - list files not synced, opened, or added in p4 client workspace
# Author: Noah Friedman <friedman@splode.com>
# Created: 2000-03-10
# Public domain.

# $Id$

# Commentary:

# Usage: p4-not-added
#        p4-not-added [dir1 [dir2 [...]]]

# Print a list of all files in the working directory of the p4 client view
# which are not actually part of the repository via a p4 add or sync.
#
# The following files are ignored:
#   * Emacs backup (~) and autosave (#foo#) files.
#   * without "-a" option, files ending in .o, .a, .so, or .so.[version-number]

# Code:

use strict;

use FindBin;
use lib "$FindBin::Bin/../lib/perl";
use lib "$ENV{HOME}/lib/perl";

use NF::P4cmd     qw(:direct);
use NF::FileUtil  qw(:name :dir);

my %opt = ( all => 0 );

sub parse_options
{
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev));
  my $succ = $parser->getoptions
    ( "D|debug" => \$NF::P4cmd::DEBUG,
      "a|all"   => \$opt{all},
    );
}

sub make_p4_patterns
{
  map { if    (m=(?:\.\.\.|\*)$=) { $_ }
        elsif (-d $_)             { "$_/..." }
        else                      { $_ }
      } @_;
}

sub in_depot
{
  my $p4info = shift;

  my $client_re  = "^" . quotemeta ("//" . $p4info->{clientName});
  my $clientRoot = $p4info->{clientRoot};

  my @pats = make_p4_patterns (@_);

  # Have picks up files already submitted;
  # opened finds new but already added files.
  my %file;

  map { $file{$_->{path}} = 1;
      } p4 (\@pats, "have");

  map { (my $lf = $_->{clientFile}) =~ s/$client_re/$clientRoot/o;
        $file{$lf} = 1;
      } p4 (\@pats, "opened");

  return \%file;
}

sub local_files
{
  my %file;

  my $re = ($opt{all}
            ? qr=(?:[#~]|\.o)$=
            : qr=(?:[#~]|\.[ao]|\.so(?:|[\d.]+)|\.lib|.dll)$=
           );

  my $fn = sub { $file{$_[0]} = 1 unless $_[0] =~ /$re/ };
  map { grind_over_tree ($_, $fn) } @_;
  return \%file;
}

sub main
{
  parse_options (\@_);

  my $whole_workspace = @_ == 0;

  my $p4info = [p4 ("info")]->[0];
  @_ = ($p4info->{clientRoot}) unless @_;

  use vars qw(%in_depot);
  local *in_depot = in_depot ($p4info, @_);

  use vars qw(%localfile);
  local *localfile = local_files (map { expand_file_name $_ } @_);

  map { delete $localfile{$_} } keys %in_depot;

  if ($whole_workspace)
    {
      map { print $_, "\n" } sort keys %localfile;
    }
  else
    {
      my $cwd = $p4info->{clientCwd};
      map { print make_relative_directory_path ($_, $cwd), "\n"
          } sort keys %localfile;
    }
}

main (@ARGV);

# eof
