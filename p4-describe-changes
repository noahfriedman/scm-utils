#!/usr/bin/env perl
# p4-describe-changes - combine p4 change and p4 describe -s
# Author: Noah Friedman <friedman@splode.com>
# Created: 2014-11-13
# Public domain.

# $Id: p4-describe-changes,v 1.8 2016/06/15 18:44:19 friedman Exp $

# Commentary:
# Code:

use strict;

use FindBin;
use lib "$FindBin::Bin/../lib/perl";
use lib "$ENV{HOME}/lib/perl";

use Getopt::Long;
use Pod::Usage;
use POSIX qw(strftime);

use NF::P4cmd qw(:direct);

use constant { FL_CHG   => 0,
               FL_FILE  => 1,
               FL_SREV  => 2,
               FL_EREV  => 3,
               FL_HOW   => 4,
               FL_REV   => 5,
             };

my %opt = ( traditional => 0,
            show_integs => 0,
            show_desc   => 1,
            show_files  => 1,
            show_jobs   => 1,
            reverse     => 0,
          );

sub parse_options
{
  my $help = -1;

  p4_process_cmdline_options ($_[0]);
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev no_ignore_case));
  my $succ = $parser->getoptions
    ( "debug"           => \$NF::P4cmd::DEBUG,
      "h|?|help+"       => \$help,
      "r|reverse"       => \$opt{reverse},

      "t|traditional!"  => \$opt{traditional},
      "i|integrations!" => \$opt{show_integs},
      "d|descriptions!" => \$opt{show_desc},
      "f|files!"        => \$opt{show_files},
      "j|jobs!"         => \$opt{show_jobs},
      # The long options above are automatically negated
      "T"               => sub { $opt{traditional} = 0 },
      "I!"              => sub { $opt{show_integs} = 0 },
      "D"               => sub { $opt{show_desc}   = 0 },
      "F"               => sub { $opt{show_files}  = 0 },
      "J"               => sub { $opt{show_jobs}  = 0 },
    );

  pod2usage (-exitstatus => 1, -verbose => 0)     unless $succ;
  pod2usage (-exitstatus => 0, -verbose => $help) if $help >= 0;

  if ($opt{traditional}
      && ($opt{show_integs}
          || !$opt{show_desc}
          || !$opt{show_files}
          || !$opt{show_jobs}))
    {
      (my $progname = $0) =~ s=.*/==;
      pod2usage (-message => "$progname: --traditional may not be used with any other formatting options.\n",
                 -exitval => 1,
                 -verbose => 0);
    }
}

sub p4error
{
  my $errorcount = 0;
  for my $elt (@_)
    {
      if (exists $elt->{code} && $elt->{code} eq 'error')
        {
          $errorcount++;
          (my $err = $elt->{data}) =~ s/^/p4: /gm;
          print STDERR $err, "\n";
        }
    }
  return $errorcount;
}

sub get_changes
{
  my $list = shift;
  map { p4error ($_) ? () : $_->{change} } p4 ($list, "changes", @_);
}

sub get_describe
{
  my @desc;
  my @shelved;

  for my $elt (p4 (\@_, qw(describe -s)))
    {
      next if p4error ($elt);
      if (exists $elt->{shelved} && !exists $elt->{rev})
        { push @shelved, $elt->{change} }
      else
        { push @desc, $elt }
    }

  push @desc, map { p4error ($_) ? () : $_
                  } p4 (\@shelved, qw(describe -S -s))
    if @shelved;

  return @desc;
}

sub get_filelog
{
  my $flist = shift;
  my %flog;
  for my $elt (p4 ($flist, qw(filelog -s)))
    {
      # Files that are newly shelved don't have a log yet.
      next if exists $elt->{code} && $elt->{code} eq 'error';

      my $depotFile = $elt->{depotFile};
      my $n = scalar @{$elt->{change}};
      for (my $i = 0; $i < $n; $i++)
        {
          my $change = $elt->{change}->[$i];
          my $rev    = $elt->{rev}->[$i];

          my @fdata = ($change);
          if (exists $elt->{file} && defined $elt->{file}->[$i])
            {
               $fdata[FL_FILE] = $elt->{file}->[$i]->[0];
              ($fdata[FL_SREV] = $elt->{srev}->[$i]->[0]) =~ s/#//;
              ($fdata[FL_EREV] = $elt->{erev}->[$i]->[0]) =~ s/#//;
               $fdata[FL_HOW]  = $elt->{how}->[$i]->[0];
            }
          $flog{$depotFile}->{$rev} = \@fdata;
        }
    }
  return \%flog;
}

my $fstat_fields = join (",", (qw(depotFile
                                  headRev
                                  resolveAction0
                                  resolveFromFile0
                                  resolveStartFromRev0
                                  resolveEndFromRev0
                                )));
sub get_shelved_fstat
{
  my $change = shift;

  my %result;
  for my $elt (p4 (qw(fstat -Os -Or -Rs),
                   '-e', $change, '-T', $fstat_fields, '//...'))
    {
      next if p4error ($elt) || exists $elt->{desc};
      next unless exists $elt->{resolveFromFile};

      my @fdata = ($change);
      $fdata[FL_FILE] = $elt->{resolveFromFile}->[0];
      $fdata[FL_SREV] = $elt->{resolveStartFromRev}->[0] - 1; # mimic filelog
      $fdata[FL_EREV] = $elt->{resolveEndFromRev}->[0];
      $fdata[FL_HOW]  = $elt->{resolveAction}->[0];
      $fdata[FL_REV]  = $elt->{headRev} || 1;  # Branched files are first rev

      $result{$elt->{depotFile}} = \@fdata;
    }
  return \%result;
}

sub integ_map
{
  my %change;
  my %shelve;

  for my $elt (@_)
    {
      next if p4error ($elt);
      next unless exists $elt->{rev};  # no files in change

      my $change    = $elt->{change};
      my $depotFile = $elt->{depotFile};

      if (exists $elt->{shelved} && $elt->{status} eq 'pending')
        {
          # Shelved files are a hairy mess.
          # Get the fstat information and if there is any, then for each file
          # that has a revision of "none", replace the element in %change
          # with the fstat information and call that revision #1.

          my $fstat = $shelve{$change} = get_shelved_fstat ($change);
          my $rev = $elt->{rev};

          for (my $i = 0; $i < @$depotFile; $i++)
            {
              next unless $rev->[$i] eq 'none';
              my $file = $fstat->{$depotFile->[$i]};
              next unless defined $file;
              $rev->[$i] = $file->[FL_REV];
            }
        }

      my @rev = @{$elt->{rev}}; # make copy, since destroying
      $change{$change} = { map { $_ => shift @rev } @$depotFile };
    }

  my @flist;
  map { while (my ($file, $rev) = each %$_)
          {
            next if $rev eq 'none';
            push @flist, $file . "#=" . $rev;
          }
      } values %change;
  # Copy in the shelved file branch/integs
  while (my ($change, $depotFile_tbl) = each %shelve)
    {
      while (my ($depotFile, $elt) = each %$depotFile_tbl)
        {
          next unless defined $elt->[FL_FILE];
          push @flist, $elt->[FL_FILE] . "#=" . $elt->[FL_EREV];
        }
    }
  my $filelog = get_filelog (\@flist);
  # Copy in any fstat information from shelves into the filelog.
  map { while (my ($depotFile, $elt) = each %$_)
          {
            my $rev = $elt->[FL_REV];
            if (ref $filelog->{$depotFile} eq 'HASH')
              { $filelog->{$depotFile}->{$rev} = $elt }
            else
              { $filelog->{$depotFile} = { $rev => $elt } }
          }
      } values %shelve;

  # Now get the change number of the source files.
  undef @flist;
  while (my ($depotFile, $elt) = each %$filelog)
    {
      while (my ($rev, $vals) = each %$elt)
        {
          next unless @$vals > 1;
          push @flist, $vals->[FL_FILE] . "#=" . $vals->[FL_EREV];
        }
    }
  if (@flist)
    {
      my $histmap = get_filelog (\@flist);
      while (my ($depotFile, $elt) = each %$filelog)
        {
          while (my ($rev, $vals) = each %$elt)
            {
              next unless @$vals > 1;
              my $file = $vals->[FL_FILE];
              my $erev = $vals->[FL_EREV];
              $vals->[FL_CHG] = $histmap->{$file}->{$erev}->[FL_CHG];
            }
        }
    }

  # Merge the filelog into the integ table.
  while (my ($changeno, $depotFile_tbl) = each %change)
    {
      while (my ($depotFile, $revno) = each %$depotFile_tbl)
        {
          my $data = $filelog->{$depotFile}->{$revno};
          if ($data && @$data > 1)
            { $depotFile_tbl->{$depotFile} = { $revno => $data } }
          else
            { delete $depotFile_tbl->{$depotFile} }
        }
      delete $change{$changeno} unless %{$change{$changeno}};
    }
  return \%change;
}

sub change_integs
{
  my ($tbl, $change) = @_;

  my $depotFile_tbl = $tbl->{$change};
  my %integs = ( map { map { $_ && @$_ > 1 ? ($_->[FL_CHG] => 1) : ();
                           } values %$_;
                     } values %$depotFile_tbl);
  sort keys %integs;
}

sub integ_of
{
  my ($integs, $changeno, $file, $rev) = @_;

  my $change_tbl = $integs->{$changeno};
  return unless $change_tbl;

  my $file_tbl = $change_tbl->{$file};
  return unless $file_tbl;

  my $rev_list = $file_tbl->{$rev};
  return unless $rev_list && @$rev_list > 1;

  my $chg  = $rev_list->[FL_CHG];
  my $how  = $rev_list->[FL_HOW];
  my $from = $rev_list->[FL_FILE];
  my $srev = $rev_list->[FL_SREV];
  my $erev = $rev_list->[FL_EREV];

  my $range = "";
  $srev = 0 if $srev eq 'none';
  $srev++; # not sure why this is always 1 less than inclusive range
  $range .= "#$srev," unless $erev eq $srev;
  $range .= "#$erev";

  return ($how, $chg, $from, $range);
}

# This is slightly different from the standard output from p4
sub describe_change
{
  my ($change, $integs) = @_;
  return unless $change->{code} eq 'stat';  # todo: print error messages

  my $stamp = strftime ("%Y-%m-%d %H:%M:%S %z", localtime ($change->{time}));

  my $status = ($change->{status} eq 'submitted'
                ? ""
                : sprintf (" *%s*", $change->{status}));

  my $changeno = $change->{change};
  printf("%s %d  %s  %s@%s%s\n\n",
         (exists $change->{shelved} ? "Shelf" : "Change"),
         $changeno,
         $stamp,
         $change->{user},
         $change->{client},
         $status);

  if ($opt{show_desc} && $change->{desc} ne '')
    {
      (my $desc = $change->{desc}) =~ s/^/\t/mg;
      print $desc, "\n";
      print "\n" unless $desc =~ /\n$/s;
    }

  if ($opt{show_jobs} && exists $change->{job})
    {
      my ($job, $jst) = ($change->{job}, $change->{jobstat});
      my @joblist;
      for (my $i = 0; $i < @$job; $i++)
        {
          my ($j, $s) = ($job->[$i], $jst->[$i]);
          $j .= sprintf ("(*%s*)", $s) unless $s eq 'fixed';
          push @joblist, $j;
        }
      print "\tJobs: ", join (" ", @joblist), "\n\n";
    }

  if ($integs)
    {
      my @integs = change_integs ($integs, $changeno);
      print "\tIntegrated changes: @integs\n\n" if @integs;
    }

  if ($opt{show_files})
    {
      my $tmpl = "\t%3s %-5s  %-11s  %s\n";
      map { my $rev    = shift @{$change->{rev}};
            my $action = shift @{$change->{action}};
            my @integ;

            printf($tmpl, '...', '#' . $rev, $action, $_);
            if ($integs
                && (@integ = integ_of ($integs, $changeno, $_, $rev)))
              {
                my $s = sprintf ("%s %s %s%s", @integ);
                printf ($tmpl, '', '', $s, '');
              }
            print "\n" if $integs->{$changeno};

          } @{$change->{depotFile}};
      print "\n";
    }
}

sub main
{
  parse_options (\@_);

  my (@changelist, @option, @path);
  map { if    (/^\d+$/) { push @changelist, $_ }
        elsif (/^-/)    { push @option,     $_ }
        else            { push @path,       $_ }
      } @_;
  push @changelist, get_changes (\@path, @option) if @path;

  if ($opt{traditional})
    {
      @changelist = sort { ($opt{reverse}
                            ? $a <=> $b
                            : $b <=> $a);
                         } @changelist;
      p4 (\@changelist, qw(describe -s))
    }
  else
    {
      my @desc   = get_describe (@changelist);
      my $integs = integ_map (@desc) if $opt{show_integs};

      map { describe_change ($_, $integs)
          } sort { ($opt{reverse}
                    ? $a->{change} <=> $b->{change}
                    : $b->{change} <=> $a->{change});
                 } @desc;
    }

  return $?;
}

main (@ARGV);

1;

__END__

=head1 NAME

 p4-describe-changes - combine "p4 changes" with "p4 describe -s"

=head1 SYNOPSIS

     {--debug}             {-?|-h|--help}            {-r|--reverse}
     {-t|--traditional}    {-T|--no-traditional}     {--p4user   USER}
     {-i|--integrations}   {-I|--no-integrations}    {--p4port   PORT}
     {-d|--descriptions}   {-D|--no-descriptions}    {--p4client CLIENT}
     {-f|--files}          {-F|--no-files}           {--p4dir    DIR}
     {-j|--jobs}           {-J|--no-jobs}            {--p4host   HOST}

     ... changelists or files


 The -h option may be repeated up to 3 times for increased verbosity.

=head1 OPTIONS

Long-format options may be abbreviated as long as the result is not ambiguous.

If you need to pass options through to C<p4 changes>, e.g. C<-m1>, specify
them after the C<--> parameter to end this script's own option processing.

=over 8

=item B<-r>, B<--reverse>

Display changes from oldest to newest.
By default, changes are displayed from newest to oldest.

=item B<-t>, B<--traditional>

Use builtin C<p4 describe> output format instead of slightly modified custom
format implemented in this script.

If this option is specified, none of the options below may be used.

=item B<-i>, B<--integrations>

Show which changes, if any, were integrated into each change and display
which origin each submitted file was integrated, branched, copied, or
merged from.

=item B<-d>, B<--descriptions>

Display the description of the change.  This is the default.

=item B<-f>, B<--files>

Display the files associated with the change.  This is the default.

=item B<-j>, B<--jobs>

Display the job names fixed by the change.  This is the default.

=back

The inverse options are as follows.

=over 8

=item B<-T>, B<--no-traditional>

Do not use builtin C<p4 describe> formatting.  This is the default.

=item B<-I>, B<--no-integrations>

Do not display changes or files integrated into the change.
This is the default.

=item B<-D>, B<--no-descriptions>

Do not display the change description.

=item B<-F>, B<--no-files>

Do not display the files associated with each change.

If this option is combined with B<--integrations>, the output will include
a list of the integrated changes but will not display the individual files
from those changes.

=item B<-J>, B<--no-jobs>

Do not display job names fixed by the change.

=back

=head1 DESCRIPTION

The command

    p4-describe-changes p14.2/...@\>2014/11/11,\<2014/11/12

performs essentially the more torturous equivalent of

    p4 changes p14.2/...@\>2014/11/11,\<2014/11/12  | awk '{print $2}' | p4 -x - describe -s

but with the same or easier-to-read results.

The usual flags to C<p4 changes> work, e.g.

    p4-describe-changes -- -s pending -u noahf //depot/main/...

    p4-describe-changes 962492

Use the B<--p4*> options to override P4PORT, P4USER, etc.

=cut
