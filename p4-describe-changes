#!/usr/bin/env perl
# p4-describe-changes - combine p4 change and p4 describe -s
# Author: Noah Friedman <friedman@splode.com>
# Created: 2014-11-13
# Public domain.

# $Id: p4-describe-changes,v 1.2 2016/06/14 01:26:54 friedman Exp $

# Commentary:
# Code:

use strict;

use FindBin;
use lib "$FindBin::Bin/../lib/perl";
use lib "$ENV{HOME}/lib/perl";

use Getopt::Long;
use Pod::Usage;
use POSIX qw(strftime);

use NF::P4cmd qw(:direct);

use constant { FL_CHG   => 0,
               FL_FILE  => 1,
               FL_SREV  => 2,
               FL_EREV  => 3,
               FL_HOW   => 4,
             };

my %opt = ( traditional => 0,
            show_integs => 0,
            show_desc   => 1,
            show_files  => 1,
          );

sub parse_options
{
  my $help = -1;

  p4_process_cmdline_options ($_[0]);
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev no_ignore_case));
  my $succ = $parser->getoptions
    ( "debug"           => \$NF::P4cmd::DEBUG,
      "h|?|help+"       => \$help,

      "t|traditional!"  => \$opt{traditional},
      "i|integrations!" => \$opt{show_integs},
      "d|descriptions!" => \$opt{show_desc},
      "f|files!"        => \$opt{show_files},

      # The long options above are automatically negated
      "T"               => sub { $opt{traditional} = 0 },
      "I!"              => sub { $opt{show_integs} = 0 },
      "D"               => sub { $opt{show_desc}   = 0 },
      "F"               => sub { $opt{show_files}  = 0 },
    );

  pod2usage (-exitstatus => 1, -verbose => 0)     unless $succ;
  pod2usage (-exitstatus => 0, -verbose => $help) if $help >= 0;

  if ($opt{traditional}
      && ($opt{show_integs} || !$opt{show_desc} || !$opt{show_files}))
    {
      (my $progname = $0) =~ s=.*/==;
      pod2usage (-message => "$progname: --traditional may not be used with any other formatting options.\n",
                 -exitval => 1,
                 -verbose => 0);
    }
}

sub p4error
{
  my $errorcount = 0;
  for my $elt (@_)
    {
      if (exists $elt->{code} && $elt->{code} eq 'error')
        {
          $errorcount++;
          (my $err = $elt->{data}) =~ s/^/p4: /gm;
          print STDERR $err, "\n";
        }
    }
  return $errorcount;
}

sub get_changes
{
  my $list = shift;
  map { p4error ($_) ? () : $_->{change} } p4 ($list, "changes", @_);
}

sub get_describe
{
  map { p4error ($_) ? () : $_ } p4 (\@_, "describe", "-s");
}

sub get_filelog
{
  my $flist = shift;
  my %flog;
  for my $elt (p4 ($flist, qw(filelog -s)))
    {
      # Files that are newly shelved don't have a log yet.
      next if exists $elt->{code} && $elt->{code} eq 'error';

      my $depotFile = $elt->{depotFile};
      my $n = scalar @{$elt->{change}};
      for (my $i = 0; $i < $n; $i++)
        {
          my $change = $elt->{change}->[$i];
          my $rev    = $elt->{rev}->[$i];

          my @fdata = ($change);
          if (exists $elt->{file} && defined $elt->{file}->[$i])
            {
               $fdata[FL_FILE] = $elt->{file}->[$i]->[0];
              ($fdata[FL_SREV] = $elt->{srev}->[$i]->[0]) =~ s/#//;
              ($fdata[FL_EREV] = $elt->{erev}->[$i]->[0]) =~ s/#//;
               $fdata[FL_HOW]  = $elt->{how}->[$i]->[0];
            }
          $flog{$depotFile}->{$rev} = \@fdata;
        }
    }
  return \%flog;
}

sub integ_map
{
  my %change = map
    { if    (p4error ($_))      { () }  # empty list
      # shelf with no file list, restricted change, or change with no files
      # left because they have been subsequently obliterated.
      elsif (!exists $_->{rev}) { () }
      else
        {
          my @rev = @{$_->{rev}}; # make copy, since modifying
          $_->{change} => { map { $_ => shift @rev } @{$_->{depotFile}} };
        }
    } @_;

  my @flist;
  map { while (my ($file, $rev) = each %$_)
          {
            push @flist, $file . "#=" . $rev;
          }
      } values %change;
  my $filelog = get_filelog (\@flist);

  undef @flist;
  while (my ($depotFile, $elt) = each %$filelog)
    {
      while (my ($rev, $vals) = each %$elt)
        {
          next unless @$vals > 1;
          push @flist, $vals->[FL_FILE] . "#=" . $vals->[FL_EREV];
        }
    }
  if (@flist)
    {
      my $histmap = get_filelog (\@flist);
      while (my ($depotFile, $elt) = each %$filelog)
        {
          while (my ($rev, $vals) = each %$elt)
            {
              next unless @$vals > 1;
              my $file = $vals->[FL_FILE];
              my $erev = $vals->[FL_EREV];
              $vals->[FL_CHG] = $histmap->{$file}->{$erev}->[FL_CHG];
            }
        }
    }

  while (my ($changeno, $depotFile_tbl) = each %change)
    {
      while (my ($depotFile, $revno) = each %$depotFile_tbl)
        {
          my $data = $filelog->{$depotFile}->{$revno};
          if ($data && @$data > 1)
            {
              $depotFile_tbl->{$depotFile} = { $revno => $data };
            }
          else
            {
              delete $depotFile_tbl->{$depotFile};
            }
        }
      delete $change{$changeno} unless %{$change{$changeno}};
    }
  return \%change;
}

sub change_integs
{
  my ($tbl, $change) = @_;

  my $depotFile_tbl = $tbl->{$change};
  my %integs = ( map { map { $_ && @$_ > 1 ? ($_->[FL_CHG] => 1) : ();
                           } values %$_;
                     } values %$depotFile_tbl);
  sort keys %integs;
}

sub integ_of
{
  my ($integs, $changeno, $file, $rev) = @_;

  my $change_tbl = $integs->{$changeno};
  return unless $change_tbl;

  my $file_tbl = $change_tbl->{$file};
  return unless $file_tbl;

  my $rev_list = $file_tbl->{$rev};
  return unless $rev_list && @$rev_list > 1;

  my $chg  = $rev_list->[FL_CHG];
  my $how  = $rev_list->[FL_HOW];
  my $from = $rev_list->[FL_FILE];
  my $srev = $rev_list->[FL_SREV];
  my $erev = $rev_list->[FL_EREV];

  my $range = "";
  $srev = 0 if $srev eq 'none';
  $srev++; # not sure why this is always 1 less than inclusive range
  $range .= "#$srev," unless $erev eq $srev;
  $range .= "#$erev";

  return ($how, $chg, $from, $range);
}

# This is slightly different from the standard output from p4
sub describe_change
{
  my ($change, $integs) = @_;
  return unless $change->{code} eq 'stat';  # todo: print error messages

  my $stamp = strftime ("%Y-%m-%d %H:%M:%S %z", localtime ($change->{time}));

  my $status = ($change->{status} eq 'submitted'
                ? ""
                : sprintf (" *%s*", $change->{status}));

  my $changeno = $change->{change};
  printf("%s %d  %s  %s@%s%s\n\n",
         (exists $change->{shelved} ? "Shelf" : "Change"),
         $changeno,
         $stamp,
         $change->{user},
         $change->{client},
         $status);

  if ($opt{show_desc})
    {
      (my $desc = $change->{desc}) =~ s/^/\t/mg;
      print $desc, "\n";
    }

  if ($integs)
    {
      my @integs = change_integs ($integs, $changeno);
      print "\tIntegrated changes: @integs\n\n" if @integs;
    }

  if ($opt{show_files})
    {
      my $tmpl = "\t%3s %-4s  %-11s  %s\n";
      map { my $rev    = shift @{$change->{rev}};
            my $action = shift @{$change->{action}};
            my @integ;

            printf($tmpl, '...', '#' . $rev, $action, $_);
            if ($integs
                && (@integ = integ_of ($integs, $changeno, $_, $rev)))
              {
                my $s = sprintf ("%s %s %s%s", @integ);
                printf ($tmpl, '', '', $s, '');
              }
            print "\n" if $integs->{$changeno};

          } @{$change->{depotFile}};
      print "\n";
    }
}

sub main
{
  parse_options (\@_);

  my (@changelist, @option, @path);
  map { if    (/^\d+$/) { push @changelist, $_ }
        elsif (/^-/)    { push @option,     $_ }
        else            { push @path,       $_ }
      } @_;
  push @changelist, get_changes (\@path, @option) if @path;

  if ($opt{traditional})
    {
      get_describe (@changelist);
    }
  else
    {
      my @desc   = get_describe (@changelist);
      my $integs = integ_map (@desc) if $opt{show_integs};

      map { describe_change ($_, $integs) } @desc;
    }

  return $?;
}

main (@ARGV);

1;

__END__

=head1 NAME

 p4-describe-changes - combine "p4 changes" with "p4 describe -s"

=head1 SYNOPSIS

     {--debug}             {-?|-h|--help}            {--p4user   USER}
     {-t|--traditional}    {-T|--no-traditional}     {--p4port   PORT}
     {-i|--integrations}   {-I|--no-integrations}    {--p4client CLIENT}
     {-d|--descriptions}   {-D|--no-descriptions}    {--p4dir    DIR}
     {-f|--files}          {-F|--no-files}           {--p4host   HOST}

 The -h option may be repeated up to 3 times for increased verbosity.

=head1 OPTIONS

Long-format options may be abbreviated as long as the result is not ambiguous.

If you need to pass options through to C<p4 changes>, e.g. C<-m1>, specify
them after the C<--> parameter to end this script's own option processing.

=over 8

=item B<-t>, B<--traditional>

Use builtin C<p4 describe> output format instead of slightly modified custom
format implemented in this script.

If this option is specified, none of the remaining options may be used.

=item B<-i>, B<--integrations>

Show which changes, if any, were integrated into each change and display
which origin each submitted file was integrated, branched, copied, or
merged from.

=item B<-d>, B<--descriptions>

Display the description of the change.  This is the default.

=item B<-f>, B<--files>

Display the files associated with the change.  This is the default.

=back

The inverse options are as follows.

=over 8

=item B<-T>, B<--no-traditional>

Do not use builtin C<p4 describe> formatting.  This is the default.

=item B<-I>, B<--no-integrations>

Do not display changes or files integrated into the change.
This is the default.

=item B<-D>, B<--no-descriptions>

Do not display the change description.

=item B<-F>, B<--no-files>

Do not display the files associated with each change.

If this option is combined with B<--integrations>, the output will include
a list of the integrated changes but will not display the individual files
from those changes.

=back

=head1 DESCRIPTION

The command

    p4-describe-changes p14.2/...@\>2014/11/11,\<2014/11/12

performs essentially the more torturous equivalent of

    p4 changes p14.2/...@\>2014/11/11,\<2014/11/12  | awk '{print $2}' | p4 -x - describe -s

but with the same or easier-to-read results.

The usual flags to C<p4 changes> work, e.g.

    p4-describe-changes -- -s pending -u noahf //depot/main/...

    p4-describe-changes 962492

Use the B<--p4*> options to override P4PORT, P4USER, etc.

=cut
